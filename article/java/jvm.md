# 内存模型

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_08-20-45.png)

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_08-25-50.png" style="zoom:67%;" />

## 程序计数器

是当前线程所执⾏的字节码的⾏号指示器，分⽀、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**程序计数器是唯⼀⼀个不会出现 OutOfMemoryError 的内存区域**

##  Java 虚拟机栈

局部变量表主要存放了编译期可知的各种数据类型、对象引⽤。调用方法时，虚拟机将局部变量表的数值传给参数变量表，实现实参向形参的传值。若执行的是实例方法，那局部变量表中0索引变量槽将被this指针占用。

**Java 虚拟机栈会出现两种错误： StackOverFlowError 和 OutOfMemoryError 。**

## 本地⽅法栈

 java虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务。此外，与 java虚拟机栈基本无二。

## 堆

堆的唯⼀⽬的就是存放对象实例，⼏乎所有的对象实例以及数组都在这⾥分配内存。Jdk1.7以后又新移入了**字符串常量池**。

### 字符串常量池

JVM为了提升性能和减少内存开销，避免字符串的重复创建，将字符串常量池交由String类私有维护，用于存放字符串的引用或者字符串。

## ⽅法区（元空间）

⽅法区与 Java 堆⼀样，是各个线程共享的内存区域，它⽤于存储已被虚拟机加载的类信息、常
量、静态变量、即时编译器编译后的代码等数据。

### 运⾏时常量池（常量池）

Class ⽂件中除了有类的版本、字段、⽅法、接⼝等描述信息外，还有常量池表（⽤于存放编译期⽣成的各种字⾯量和符号引⽤）

## 直接内存

Java进程所在的宿主机内存，也叫做堆外内存，并不**直接**由JVM直接管理和回收；借助NIO使用native函数库直接分配堆外内存，通过VM堆中的DirectByteBuffer对象对这块内存进行引用和操作，从而避免Java堆与宿主机内存的来回复制操作。

# 各种量、值的存储位置

+ 类、接口，数组、对象：===== 堆
+ 成员变量：===== 堆
+ 字面量：===== 堆（字符串常量池）
+ 静态方法、静态变量：===== 方法区
+ 方法中间值、参数，局部变量，引用：=====栈（ 局部变量表）

# class结构

## 硬盘中的.class文件结构

### class文件

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-08_08-26-34.png)

### 常量池

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-08_09-15-21.png" style="zoom:67%;" />

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-08_09-12-54.png)

共17项



### 访问标志 access_flags

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-08_08-33-58.png)

access_flags中一共有16个标志位可以使用，当前只定义了其中9个 ，没有使用到的标志位要求一
律为零。

### “类”索引

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-08_08-37-00.png)

通过以上方式查找、解析全限定名。

### 字段表

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-08_08-53-47.png)

### 方法表

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-08_09-43-30.png)

### 属性表

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-08_09-52-38.png)



# 常量池

## 静态常量池（Class常量池）

*.class文件中的常量池，在编译期被确定。可以理解为是Class文件的资料库，它包含类的版本、字段、方法、接口等描述信息，也包括各种字面量和符号引用。占用class文件绝大部分空间。

## 运⾏时常量池

方法区的一部分，存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。在class文件被加载进了内存之后，**运行时常量池保存在了方法区中**，通常说的常量池指的是运行时常量池。

## 字符串常量池

堆的一部分，本质是一个HashSet<String>，这是一个纯运行时的结构，而且是惰性维护的。注意它只存储String对象的引用，而不存储String对象的内容，根据这个引用可以得到具体的String对象。

### 作用

为了避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享。

1. 节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。
2. 节省运行时间：比较字符串时，比equals()快。对于两个引用变量，只用判断引用是否相等，也就可以判断实际值是否相等



# JVM数据模型

## klass模型

一般jvm在加载class文件时，会在方法区创建instanceKlass，表示其元数据，包括常量池、字段、方法等。 **java类在JVM中的存在形式 ： java类->c++的类 klass** 

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_09-31-31.png" style="zoom: 67%;" />

+ InstanceKlass：表示普通java类在JVM中的实例。
+ InstanceMirrorKlass：表示java.lang.Class对象，在java中获取到的class对象，就是其实例，存储在堆区，也叫镜像类。
+ InstanceRefKlass：用于表示java.lang.ref.Reference类的子类。
+ InstanceClasLoaderKlass:表示类加载器，主要用于遍历类加载器加载的类。
+ TypeArrayKlass: 表示基本类型数组。
+ ObjArrayKlass：表示引用类型数组
  

## OOP模型

 **java对象在JVM中的存在形式 ： java对象 -> c++的对象** 

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_09-31-59.png" style="zoom:67%;" />

+ InstanceOopDesc：表示除数组外的其它对象。
+ MarkOopDesc：保存了java对象的一些信息，如哈希码、GC分代年龄、偏向锁标记、线程持有锁、偏向线程的ID、偏向时间戳。
+ TypeArrayOopDesc：基本类型数组对象。
+ ObjArrayOopDesc：引用类型数组对象。
  

### OOP模型内存结构

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_09-34-19.png" style="zoom:67%;" />

**指针压缩**：64bit才有这项技术；达到的效果 指针8B->4B【8B对齐】 **原理**：8的二进制数为1000；任何8的倍数的二进制数都有3个0，存储时将其去除【右移3位】，使用时再添上【左移3位】

### 对象头

对象头区域分为三部分，Mark Word，类型指针，数组长度。

+ **Mark Word**：标记字。主要用来表示对象的线程锁状态，存放对象hashCode、GC次数。32bit占用：4B； 64bit占用：8B

+ **类型指针**(Klass pointer):指向Class信息的指针，表示该对象是哪个Class的实例。 开启**指针压缩**【64bit的技术】：4B； 关闭指针压缩：8B

+ **数组长度**，当对象不是数组对象时，该区域不占空间。 默认占用4B【ffff】

+ **【注意】：关闭指针压缩下，数组对象在数组长度之后还会后一次对其填充以<u>保证对象头8字节对齐</u>**

  ```
  非数组对象
  	开启指针压缩:
  		MarkWord8B+类型指针4B+数组长度0B=12B【4B填充实例数据】
      关闭指针压缩:  
      	MarkWord8B+类型指针8B+数组长度0B=16B【不用填充】
      	
  数组对象
  	开启指针压缩:
  		MarkWord8B+类型指针4B+数组长度4B=16B【不用填充对象头】
  		，，，依情况填充实例数据
      关闭指针压缩:  
      	MarkWord8B+类型指针8B+数组长度4B=20B【4B填充对象头】
          ，，，依情况填充实例数据
   
  为什么数组对象要两次对齐填充
  	**效率**
  1.由于普通对象就只有一个实例数据，解决了一个就解决了所有，所以普通对象填充对象头的意义不大，还会浪费内存。所以普通对象的实例数据直接接到类型指针后面就可以了，最后一次填充一劳永逸。
  2.对于数组对象，可能会包含多个实例数据。如果不进行对象头填充，像普通对象一样接到数组长度后面，那么对于不同字节长度的数据类型就要进行不同的填充实现，会增加代码的复杂度。
  ```

### 实例数据

 类的非静态属性，生成的数据就是对象的实例数据

### 对象填充区域

当一个对象的大小不足8的整数倍的时候。会填充字节。 默认8字节对齐。 假如一个对象是30字节，会默认填充2个字节，达到8字节对齐。

# 类加载机制

## 基本流程

hello.java→javac（将程序编译为字节码文件，存放在硬盘上，需要加载到内存中）→【字节码文件（字节流）JVM无法识别，需要类加载机制】→加载到内存→验证→准备→解析

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_10-00-34.png" style="zoom:67%;" />

## NO.1加载

### 【非数组类型】

0. javac编译.java文件，生成字节码文件并存于**硬盘内**【编译阶段】

1. 找到字节码文件（字节流）并载入**内存**（没有指明必须从哪获取）

   ​		1、从压缩包中读取，如jar、war 

   ​		2、从⽹络中获取，如Web Applet 

   ​		3、动态⽣成，如动态代理、CGLIB 

   ​		4、由其他⽂件⽣成，如JSP 

   ​		5、从数据库读取 

   ​		6、从加密⽂件中读取 

2. 对字节码文件进行解析，解析成运行时数据并存于**方法区**，此时字节码文件已释放

3. 在**堆区**生成该类的Class对象【**此时为空对象，什么都没有，须在准备阶段赋初值加载成员变量**】，即instanceMirrorKlass实例【生成镜类的原因的保护元信息，防止用户使用C++手段威胁JVM】，``类变量存储在堆区``

### 【数组类型】

不通过类加载器创建，而是由Java虚拟机直接在内存中动态构造出来的。如果数组装载的是引用类型元素，则会递归加载该元素的类型；若装载的元素是基本应用类型，则虚拟机会把该数组与引导类加载器关联起来。

 数组类的可访问性与它的元素类型的可访问性一致，对于基本用类型元素来说，数组类的可访问性默认为public。 

## NO.2验证

检查文件是否符合JVM规范

- 文件格式验证

  - 是否以魔数0xCAFEBABE开头。 
  - 主、次版本号是否在当前Java虚拟机接受范围之内。
  - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 
  - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 
  - CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 
  - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
  - ……

- 元数据验证

  - 是否有父类
  - 父类是否继承了不允许被继承的类（被final修饰的类）。
  - 非抽象类是否实现了父类或接口中要求实现的所有方法。
  - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。
  - ……

- 字节码验证

  利用“StackMapTable”属性，将任务前置并分摊给了编译器，此阶段只需要检查StackMapTable属性中的记录是否合法即可。

  - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
  - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，
  - 保证方法体中的类型转换总是有效的
  - ……

- 符号引用验证

  对类自身以外的各类信息进行匹配性校验，检查该类是否缺少或者被禁止访问它依赖的外部类、方法、字段等资源。确保解析阶段能正常执行。

  - 符号引用中通过字符串描述的全限定名是否能找到对应的类。 

  - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 

  - 符号引用中的类、字段、方法是否可被当前类访问。

  - ……

## NO.3准备

- 为静态变量【归属于class，但在jdk8以后存储在堆区】分配内存、赋初值。其目的是**将该变量写入class对象中去**。【初始化阶段执行静态代码段的规则 ——> 静态变量有赋值才会在静态代码段中生成代码。如果此时不声明静态变量，不为他赋初值，那么在下一步初始化赋值的时候，那些在源代码中没有赋（初）值的static int a；在静态代码段中就不会生成初始化代码，a就**会丢失**】
- 如果被**final修饰**，在编译的时候会给属性添加ConstantValue属性，准备阶段直接从常量池表中取值完成赋值，即没有赋初值这一步
- <u>实例变量是在创建对象的时候完成赋值的，没有赋初值一说</u>

## NO.4解析

解析：符号引用【常量池索引】→直接引用【能直接指向目标内容的引用（内存地址）】

+ 如果加载类中包含有其他引用类型，则在解析之前，此类型均没有指向具体的Xxx.class，仅代表一个符号【不完全类型】，通过解析后，该类型便可与实际指向的A.class文件实现映射对应。

+ 仅第一次运行时需要解析[运⾏时常量池的缓存机制【类似hashtable的数据结构】]，通过符号引用去常量池找到类信息将其存储到常量池中，其后改写，直接使用内存地址

### 解析时机

在类初始化之前检查并实现解析，由初始化触发解析

### 解析目标

对所有的符号引用都进行解析

1. 继承的类，实现的接口 ——> 存放于方法区
2. 字段 ——> 存放于堆
3. 类方法，接口方法 ——> 存放于方法区

## NO.5初始化

执行类构造器的<clinit>()方法，完成静态变量的赋值。**静态字段、静态代码段**会在字节码层面会生成clinit方法，方法中语句的先后顺序与代码的编写顺序相关。

- 如果没有静态属性，静态代码块，生成的字节码文件就没有clinit方法块
- final修饰的，不会在clinit方法块中体现，已在准备阶段赋值完毕
- 一个字节码文件只有一个clinit方法块
- clinit方法块中的代码顺序与java代码一致，会影响程序的最终结果

初始化阶段无线程安全问题，但是仍会发生初始化的死锁问题【是为JVM级别的锁，java检测工具无法识别】

### 初始化时机：

1. **new**，**访问**或**设置**某个类的<u>**静态字段**（final修饰【要求左右值均为不变量】以及位于常量池的除外</u>）、**调用某个类的静态方法**直接操作一个类 时，对该类初始化。``当父接口的变量被使用时才会被初始化。接口实现类的初始化不会触发接口的初始化。 ``
2. 反射(调用)某个类时，若该类未初始化，对该类初始化。
3. 当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化。
4. 启动类（main函数所在类）必定会初始化。
5. 若初始化类**实现了某接口的默认方法**，会先触发该接口初始化。
6. 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化

总结一句话：**用到就加载，不用不加载**

### 初始化顺序

1. ==静态的【(变量，块)从上到下】==
   1. 父类的
   2. 本类的
2. 父类非静态的【(变量，块)从上到下】
3. 父类构造函数
4. ==本类非静态的【(变量，块)从上到下】==
5. ==本类构造函数==

## 过程总结

1. .java源代码→javac编译为字节码文件.class，并存放在硬盘上
2. 将.class文件加载到jvm的方法区内
   1. 找到字节码文件并载入**内存**
   2. 对字节码文件进行解析，将生成的运行时数据【即instanceKlass实例(class结构体)】存于**方法区**，并释放.class文件
   3. 在**堆区**生成该类的Class对象【**此时为空对象**】
3. 验证，检查该.class是否符合JVM规范
4. 准备
   1. 为静态变量【归属于class】分配内存、赋初值(若被final修饰就直接完成赋值)，并将其存于堆区。
5. 解析，有常量池中的符号引用定位到直接引用。
   + 继承的类，实现的接口 ——> 进行加载并存放于方法区
   + 字段 ——> 存放于堆
   + 类方法，接口方法 ——> 存放于方法区
6. 初始化
   1. 执行静态代码块clinit，完成静态变量的赋值。

## 类加载器

根据一个类的全限定名来读取此类的二进制字节流(.class文件)到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例。

在Java中，一个类用其全限定类名作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。

### 分类

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_10-25-07.png" style="zoom:67%;" />

#### 启动（Bootstrap）类加载器

加载位于/jre/lib目录中的或者被参数-Xbootclasspath所指定的目录下的核心Java类库【rt.jar等等】。此类加载器是Java虚拟机的一部分，使用native代码(C++)编写。

#### 扩展（Extension）类加载器

加载位于/jre/lib/ext目录中的或者java.ext.dirs系统变量所指定的目录下的拓展类库。此加载器由sun.misc.Launcher$ExtClassLoader实现。由Java语言实现，父类加载器为null。

#### 应用（Application）类加载器

加载用户路径(ClassPath)上所指定的类库。此加载器由sun.misc.Launcher$AppClassLoader实现。由Java语言实现，父类加载器为ExtClassLoader。

### 双亲委派

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_10-27-59.png" style="zoom: 80%;" />

 **过程体现**

如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是委托给自己的父类去加载，父类又委托给自己的父类。因此所有的类加载都会委托给顶层的父类（Bootstrap Classloader）进行加载，然后父类自己无法完成这个加载请求，子加载器才会尝试自己去加载。

**优势**

1. **避免类的重复加载**。java的类加载器具备了一种带有优先级的层次关系，通过这种层级关系，当父类加载器已经加载了该类时，就没有必要子ClassLoader再加载一次。
2. **防止核心API库被随意篡改**。当加载一个与Java核心类库中同类名的类时，由于启动类加载器已经加载了javaAPI中的同名类，所有目标类将无法加载。

**打破双亲委派**

打破双亲委派的意思其实就是**不委派、向下委派**。出现了父类或接口【由jdk底层提供】须由启动类加载器加载，而其子类或接口【第三方提供或自定义】须由应用类加载器加载，故而出现了上层必须向下层委派的情况。

例如：在某些情况下⽗类加载器需要委托⼦类加载器去加载class⽂件。受到加载范围的限制，⽗类加载器⽆法加载到需要的⽂件，以Driver接⼝为例，由于Driver接⼝定义在jdk当中的，⽽其实现由各个数据库的服务商来提供，⽐如mysql的就写了 MySQL Connector ，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接⼝的实现类，然后进⾏管理，但是DriverManager由启动类加载器加载，只能加载JAVA_HOME的lib下⽂件，⽽其实现是由服务商提供的，由系统类加载器加载，这个时候就需要 启动类加载器来委托⼦类来加载Driver实现，从⽽破坏了双亲委派。

 Java中存在很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，是⼀种**服务发现机制**。它通过在ClassPath路径下的META-INF/services⽂件夹查找⽂件，⾃动加载⽂件⾥所定义的类。这⼀机制为很多框架扩展提供了可能，⽐如在Dubbo、JDBC中都使⽤到了SPI机制 。

# Java对象的创建过程

## Step1类加载检查

虚拟机遇到new指令时，先去检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。

## Step2分配内存

对象所需的内存⼤⼩在类加载完成后便可确定。为对象分配空间的⽅式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配⽅式由 Java 堆是否规整决定，⽽ Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。

内存分配的两种⽅式：

+ **指针碰撞：**
  + 原理：维护一个分界指针，通过控制分界指针向空闲内存方向移动，实现将使用过的内存整合划界，已达到没有内存碎片的目的
  + 适用于堆内存规整的情况
  + GC收集器：Serial、ParNew
+ **空闲列表：**
  + 原理：维护一个列表，在该表中记录可用的内存块，在分配时会找出合适大小的内存块，然后更新列表
  + 适用于堆内存不规整的情况
  + GC收集器：CMS

实现线程安全的方式：

+ **CAS+失败重试：** 冲突失败就重试，直到成功为⽌。虚拟机采⽤CAS配上失败重试的⽅式保证更新操作的原⼦性。
+ TLAB： 为每⼀个线程预先在 Eden 区分配⼀块⼉内存，JVM 在给线程中的对象分配内存
  时，⾸先在 TLAB 分配，当对象⼤于 TLAB 中的剩余内存或 TLAB 的内存已⽤尽时，再采⽤
  上述的 CAS 进⾏内存分配

## Step3赋初值

虚拟机需要为分配到的内存空间都赋初值（不包括对象头），它保证了对象的实例字段在 Java 代码中可以不赋值就直接使⽤，程序能访问到的是对应类型的零值。

## Step4设置对象头元信息

虚拟机要对对象设置必要的元信息，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。这些信息存放在对象头中。 

## Step5执⾏init⽅法

至此⼀个新的对象已经产⽣了，但从 Java 程序的视⻆来看， <init> ⽅法还没有执⾏，所有的字段都还为初值。所以执⾏ <init> ⽅法把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全产⽣出来。

# JVM 垃圾回收机制

**垃圾：**在JVM中，垃圾就是指那些在内存中存在的，而又无法使用的对象。

## **四种引用类型：**

+ 强引用（Strong Reference）：如Object obj = new Object()，这类引用是 Java 程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。当内存空间不⾜，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终⽌，也不会回收具有强引⽤的对象。
+ 软引用（Soft Reference）：它用来描述一些可有可⽆的对象。在系统内存不够用时，就会回收这些对象的内存。软引⽤可⽤来实现内存敏感的⾼速缓存。
+ 弱引用（Weak Reference）：它也是用来描述非必须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。如果弱引⽤所引⽤的对象被垃圾回收，Java虚拟机就会把这个弱引⽤加⼊到与之关联的引⽤队列中。
+ 虚引用（Phantom Reference）：虚引⽤并不会决定对象的⽣命周期。如果⼀个对象仅持有虚引⽤，那么它就和没有任何引⽤⼀样，在任何时候都可能被垃圾回收。

## 垃圾判断算法

### 引用计数法

**原理：**假设每个对象都有一个引用计数器，当对象被初始化或引用后，计数器的值就会加 1。例如将b赋给a，那么b被引用计数器累加 1。当被当做垃圾收集时，它引用的任何对象的计数器的值都减 1。引用计数为 0 的对象，就可以称之为垃圾。

**优点：**引用计数法实现起来比较简单，对程序不被长时间打断的实时环境比较有利。
		**缺点：**计数器需要额外的开销，无法检测对象之间的循环引用。

### 可达性分析法

**原理：**以GC ROOT的对象作为搜索起点，通过引用向下搜索，不能在引用链（搜索路径）中检索的对象即为垃圾，对可达的对象要进行标记。

**优点**：可以解决循环引用的问题，不需要占用额外的空间

**缺点**：多线程场景下，其他线程可能会更新已经访问过的对象的引用

**要求：**对象属于根集中的对象。包括：

+ 虚拟机栈（栈帧中的本地变量表）中引用的对象
+ 方法区中的常量引用的对象
+ 方法区中的类静态属性引用的对象
+ 本地方法栈中 JNI（Native 方法）的引用对象
+ 活跃线程（已启动且未停止的 Java 线程）

### 注意


可达标记阶段会暂停线程，这种情况被称为安全点。它这会触发一次 Stop The World（STW）暂停，该机制下所有Java代码停止运行，仅native代码可以执行且无法与JVM交互【相当于挂起了JVM】。

STW会直接影响到系统的运行，但仍然如此设计，是为了防止在GC过程中对象标记的状态发生了变化，影响了GC的执行。(例如：GC执行到半道儿上用户进程结束了，那么被GC标记保留的对象又应该被标记清除，会增加GC的执行复杂度)。

所以<u>**调优的目标，就该在保证系统不挂掉的基础上，去争取更低频率、单次GC时长更短的GC，并平衡整个系统的各个模块(依照业务需求)。**</u>

## 垃圾回收算法

### 标记-清除算法

标记-清除是为了解决引用计数法的问题而提出。它使用了根集的概念，它分为“标记”和“清除”两个阶段：首先可达性标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程就是可达性分析法中判定垃圾对象的标记过程。

**优点：**不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。
		**缺点：**标记和清除过程的效率都不高，需要维护一个空闲列表来记录所有的空闲区域以及大小，加大了开销；标记清除后会产生大量不连续的内存碎片。

### 标记-整理算法

首先可达性标记出所需回收的对象，标记的过程与“标记-清除”算法中的一样，然后让让所有存活的对象都向一端移动，直接清理掉端边界以外的内存。在基于“标记-整理”算法的收集器的实现中，一般增加句柄和句柄表。

**优点**：解决了内存碎片的问题

**缺点**：GC 暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。

### 复制算法

复制算法是为了克服句柄的开销和解决堆碎片的垃圾回收。它将内存按容量分为大小相等的两块A和B，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。

1. 向A中分配内存，某一时刻A要用完了，复制存活对象到B中，清空A
2. 转而从B中分配内存，
3. 某一时刻B要用完了，复制存活对象到A中，清空B

复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如“标记-整理”算法。

**优点：**标记阶段和复制阶段可以同时进行；每次只对一块内存进行回收，运行高效；j解决了内存碎片问题
		**缺点：**需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。

### 分代收集算法

将堆进行如下分代分区

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-06_22-04-18.png)

几乎所有新生成的对象首先都是放在年轻代的，当Eden空间申请失败时会发起一次 GC（Minor GC / **Scavenge GC**）。存活对象的年龄会+1。

1. 当Eden区要满时，复制 Eden 区和 S1 区存活对象到 S0 区，然后清空 Eden 和 S1 区 
2. 当Eden区要满时，复制 Eden 区和 S0 区存活对象到 S1 区，然后清空 Eden 和 S0 区 
3. 如此往复，S0和S1交替使用

默认情况下，如果对象年龄达到 15 岁，就会移入到老年代中。若老年代也满了就会触发一次 GC（Major GC / **Full GC**），也就是新生代、老年代都进行回收。

#### 新生代：

**为什么8:1:1的**

经研究，Eden区经过一轮GC会释放90-95%的对象，故起初设定为9:1

1. 9:1下的GC
   1. 标记-清除算法 ，有碎⽚化问题，影响内存使用效率
   2. 标记-整理算法，(整理算法,内存合并算法) ，相当耗费cpu 
2. 为了保证1.，并在不整理的情况下保证内存的完整性 ，使用分代 + 复制算法。新开辟一块区域【to区】专用于GC后存活对象的复制，然后清空Eden和from区，再to区中的对象移入from区。

#### 老年代：

1. GC超过15次的对象【具体阈值在0-15之间，可以通过`-XX：MaxTenuringThreshold`参数进行控制】
2. 大对象：超过Eden内存的1/2的对象
3. 空间担保机制：当Eden区经过GC后发现from区装不下，就会直接移入Old区
4. 动态年龄判断机制：新生代内经过多次GC后仍未释放的对象，当其GC次数超过给定阈值时会认定往后也不会被释放，将直接移入Old区。

## 垃圾回收器

垃圾回收（GC）线程与应用线程保持相对独立，当系统需要执行垃圾回收任务时，先停止工作线程，然后命令 GC 线程工作。以串行模式工作的收集器，称为Serial Collector，即串行收集器；以并行模式工作的收集器，称为Paraller Collector，即并行收集器。

### Serial 收集器

串行收集器采用单线程方式进行收集，不允许应用线程打扰，此时，应用程序进入暂停状态，即 Stop-the-world。Stop-the-world 暂停时间的长短，是衡量一款收集器性能高低的重要指标。Serial 是针对新生代的垃圾回收器，采用“复制”算法。

### ParNew 收集器

并行收集器充分利用了多处理器的优势，采用多个 GC 线程并行收集。一般来说，与串行收集器相比，在多处理器环境下工作的并行收集器能够极大地缩短 Stop-the-world 时间。ParNew 是针对新生代的垃圾回收器，采用“复制”算法，是 Serial 的多线程版本

### Parallel Scavenge 收集器

Parallel Scavenge 采用“复制”算法和 ParNew 类似，但更注重吞吐率。吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。如虚拟机总运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。
		**通过 VM 选项可以控制吞吐量的大致范围：**

+ -XX：MaxGCPauseMills：期望收集时间上限，用来控制收集对应用程序停顿的影响。
+ -XX：GCTimeRatio：期望的 GC 时间占总时间的比例，用来控制吞吐量。
+ -XX：UseAdaptiveSizePolicy：自动分代大小调节策略。

### Serial Old 收集器

Serial Old 是 Serial 收集器的老年代版本，单线程收集器，采用“标记-整理”算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。

### Parallel Old 收集器

Parallel Old 是 Parallel Scanvenge 收集器的老年代版本，多线程收集器，采用“标记-整理”算法。

### CMS收集器

CMS（`Concurrent Mark Swee`）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS 收集器仅作用于老年代的收集，采用“标记-清除”算法，它的运作过程分为 4 个步骤：

1. 初始标记（CMS initial mark）             **Stop-the-world**，仅标记GCRoots直接关联的对象
2. 并发标记（CMS concurrent mark）   标记所有的Old对象，递归扫描，并发时有引用变动的对象会产生漏标问题
3. 重新标记（CMS remark）                    **Stop-the-world**，对2的并发误差进行修正
4. 并发清除（CMS concurrent sweep） “标记-清除”算法

### 经典组合

|      新生代       |    老年代    |
| :---------------: | :----------: |
|      Serial       |  Serial Old  |
|      ParNew       |     CMS      |
| Parallel Scavenge | Parallel Old |

### G1收集器

为了实现STW的时间可预测（在任意1秒的时间内，停顿不得超过xxxms）。G1将堆内存“化整为零”得多个大小相等独立区域（Region），每一个Region均可担负新生代的Eden空间、Survivor空间，或者老年代空间。
<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_16-51-21.png" style="zoom:67%;" />

+ 每个Region的大小可以通过参数`-XX:G1HeapRegionSize`设定，取值范围为1MB~32MB，且应为2的N次幂。

+ 超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中
+ G1的进行回收大多数情况下都把Humongous Region作为老年代的一部分来进行看待。
+ G1在逻辑上还是划分Eden、Survivor、OLd，但是物理上他们不是连续的。

它的运作过程分为 4 个步骤：

1. 初始标记             **Stop-the-world**，仅标记GCRoots直接关联的对象
2. 并发标记             标记所有的Old对象，递归扫描，并发时有引用变动的对象会产生漏标问题
3. 最终标记            **Stop-the-world**，对2的并发误差进行修正
4. 筛选回收            根据用户所期望的停顿时间来制定回收计划，把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。

