# 基础杂篇

## 数值运算

+ float x = 1；float x = 1.0f。无错：低精度可向高精度自行转换
+ float x = 1.0；。**出错：**浮点数默认是double的，高转低-->失败。
+ `-5+1/4+2*-3+5.0 = double -6.0`。当多个精度的数字同时进行运算时，最终结果以最高精度为准。



## 字符型常量和字符串常量的区别

+ 形式上: 字符常量是单引号引起的⼀个字符; 字符串常量是双引号引起的若⼲个字符
+ 含义上: 字符常量相当于⼀个整型值( ASCII 值),可以参与运算; 字符串常量代表⼀个地
  址值
+ 内存占用: 字符常量只占 2 个字节; 字符串常量占若⼲个字节

| 基本类型 | 位数 | 字节 | 默认值  |
| :------: | :--: | :--: | :-----: |
|   int    |  32  |  4   |    0    |
|  short   |  16  |  2   |    0    |
|   long   |  64  |  8   |   0L    |
|   byte   |  8   |  1   |    0    |
|   char   |  16  |  2   | 'u0000' |
|  float   |  32  |  4   |   0f    |
|  double  |  64  |  8   |   0d    |
| boolean  |  1   |      |  false  |



## 字符串创建

+ 字面量形式：`String str1="aaa"; String str2="aaa";`
  1. 先去堆中的字符串常量池中查找是否存在"aaa"这个字符串对象
  2. 若无就在字符串池中创建并返回引用，若有就直接返回对象地址
  3. str1==str2为true。
+ new( )形式：`String str1=new String("aaa"); String str2=new String("aaa");`
  1. 先在字符串常量池中查找有没有"aaa"这个字符串对象
  2. 若无，则先在字符串池中创建一个再在堆中创建一个，然后返回堆中的对象地址；若有，就直接在堆中创建，返回堆中的对象地址。
  3. str1==str2为false。

## 重载和重写的区别

+ **重载：**在编译时即可实现，在同一个类中体现，在同方法名下有不同的参数列表则视为重载，返回值类型和访问修饰符也可以不相同。
+ **重写：**在运行时才可实现，体现在子父类的继承中，要求方法名，参数列表，返回类型都相同。但子类函数的访问修饰权限不能低于父类，抛出的异常范围要⼩于等于⽗类，构造⽅法⽆法被重写。

## 封装 继承 多态

+ **封装：**把对象的属性私有化，同时提供能被外界访问属性的⽅法
+ **继承：**在已存在的类的基础上建⽴新类的技术，新类可以增加新的字段或方法
  + ⼦类拥有⽗类对象所有的属性和⽅法（包括私有属性和私有⽅法），但是⽗类中的私有属性
    和⽅法⼦类是⽆法访问，只是拥有而已。
+ **多态：**上级引用（继承重写、接口覆盖）执行下级实例，在运行期确定

## 接⼝和抽象类的区别

+ **关键字：**接口使用关键字interface来定义，使用implements定义其具体实现；抽象类使用关键字 abstract 来定义，使用 extends 关键字实现继承。
+ **子扩展：**接口可以多实现，但抽象类只能单继承。
+ **访问控制符：**接口中属性和方法的访问控制符只能是public，属性默认是public static final修饰的；抽象类中的访问控制符无限制，但抽象方法不能使用 private 修饰。
+ **方法实现：**接口中的static 和 default 方法必须有实现；抽象类中普通方法可以有实现，抽象方法不能有实现。
+ **静态代码块：**接口中不能使用静态代码块；抽象类中可以使用静态代码块
+ **设计层⾯：**抽象类是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏
  为的规范。

## 成员变量与局部变量的区别

+ **形式上：**员变量可以被public、private、static等修饰符所修饰，但是局部变量不能被访问控制修饰符以及static所修饰。局部变量和成员变量都能被final修饰
+ **存储：**成员变量存在于堆内存，局部变量存在于栈内存。

+ **生命周期：**成员变量随着对象的创建而存在；局部变量随着方法的调用而自动消失。
+ **初始化：**成员变量会自动以类型的默认值而赋初值，但是局部变量则不会自动赋值。被final修饰的成员变量必须显式的赋值。

##  == 与 equals

+ **== :** 它的作⽤是判断两个对象的地址值是不是相等。即判断两个对象是不是同⼀个对象
+ **equals() :** 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：
  + 类没有覆盖 equals() ⽅法：等价于“==”。
  + 类覆盖了 equals() ⽅法：用于⽐较两个对象的内容是否一致

## hashCode 与 equals

hashCode() 的作⽤是获取哈希值，用于确定元素在哈希表中的索引位置。在有散列表参与的集合中，会依次通过hashCode()和equals()来确定元素的最终位置，并且合理的hashCode()实现可以大大提高执行效率。

若两对象相同，则它们必定会覆盖在同一个桶中的同一个位置，即hashCode值相等且equals()返回true，相反，仅凭hashCode值相等是无法精确定位元素的最终位置的。如此一来，可知，在散列表支持的集合中，判断两元素相等是需要hashCode()和equals()共同协作的，必须同时重写才能起作用。

##  如何判断⼀个常量是废弃常量?

运⾏时常量池主要回收的是废弃的常量。假如在常量池中存在字符串 "abc"，若当前没有任何String对象引⽤该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发⽣内存回收的话⽽且有必要的话，"abc" 就会被系统清理出常量池。

## 如何判断⼀个类是⽆⽤的类?

需要同时满⾜下⾯ 3 个条件：

+ 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
+ 加载该类的 ClassLoader 已经被回收。
+ 该类对应的 java.lang.Class 对象没有被引⽤，⽆法通过反射访问该类的⽅法。

##  为什么 Java 中只有值传递

按值调用表示方法接收的是调用者提供的值，而按引用调用表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 Java总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。

## 深拷贝 vs 浅拷贝

**浅拷贝：**对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，只拷贝了当前层。

**深拷贝：**对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，相当于递归进行浅拷贝。

# 集合

## HashMap 的⻓度为什么是2的幂次⽅

HashMap在定位桶索引时，使用了位运算进行了优化【hash%length==hash&(length-1)】，但该式子成立的前提就是 **length是2的n次⽅**。

# IO

## BIO,NIO,AIO 有什么区别?

+ **BIO (Blocking I/O):** 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。
+ **NIO (Non-blocking/New I/O):** NIO 是一种同步非阻塞的 I/O 模型，它支持面向缓冲，基于通道I/O 操作方法。 NIO 提供了与传统BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式与BIO基本一致，但性能和可靠性都不好；非阻塞模式正好与之相反。
+ **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步
  非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不
  会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
