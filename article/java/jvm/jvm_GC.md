
**垃圾：**在JVM中，垃圾就是指那些在内存中存在的，而又无法使用的对象。

# 四种引用类型：

+ 强引用（Strong Reference）：如Object obj = new Object()，这类引用是 Java 程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。当内存空间不⾜，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终⽌，也不会回收具有强引⽤的对象。
+ 软引用（Soft Reference）：它用来描述一些可有可⽆的对象。在系统内存不够用时，就会回收这些对象的内存。软引⽤可⽤来实现内存敏感的⾼速缓存。
+ 弱引用（Weak Reference）：它也是用来描述非必须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。如果弱引⽤所引⽤的对象被垃圾回收，Java虚拟机就会把这个弱引⽤加⼊到与之关联的引⽤队列中。
+ 虚引用（Phantom Reference）：虚引⽤并不会决定对象的⽣命周期。如果⼀个对象仅持有虚引⽤，那么它就和没有任何引⽤⼀样，在任何时候都可能被垃圾回收。

# 垃圾判断算法

## 引用计数法

**原理：**假设每个对象都有一个引用计数器，当对象被初始化或引用后，计数器的值就会加 1。例如将b赋给a，那么b被引用计数器累加 1。当被当做垃圾收集时，它引用的任何对象的计数器的值都减 1。引用计数为 0 的对象，就可以称之为垃圾。

**优点：**引用计数法实现起来比较简单，对程序不被长时间打断的实时环境比较有利。
		**缺点：**计数器需要额外的开销，无法检测对象之间的循环引用。

## 可达性分析法

**原理：**以GC ROOT的对象作为搜索起点，通过引用向下搜索，不能在引用链（搜索路径）中检索的对象即为垃圾，对可达的对象要进行标记。

**优点**：可以解决循环引用的问题，不需要占用额外的空间

**缺点**：多线程场景下，其他线程可能会更新已经访问过的对象的引用

**要求：**对象属于根集中的对象。包括：

+ 虚拟机栈（栈帧中的本地变量表）中引用的对象
+ 方法区中的常量引用的对象
+ 方法区中的类静态属性引用的对象
+ 本地方法栈中 JNI（Native 方法）的引用对象
+ 活跃线程（已启动且未停止的 Java 线程）

## 注意


可达标记阶段会暂停线程，这种情况被称为安全点。它这会触发一次 Stop The World（STW）暂停，该机制下所有Java代码停止运行，仅native代码可以执行且无法与JVM交互【相当于挂起了JVM】。

STW会直接影响到系统的运行，但仍然如此设计，是为了防止在GC过程中对象标记的状态发生了变化，影响了GC的执行。(例如：GC执行到半道儿上用户进程结束了，那么被GC标记保留的对象又应该被标记清除，会增加GC的执行复杂度)。

所以<u>**调优的目标，就该在保证系统不挂掉的基础上，去争取更低频率、单次GC时长更短的GC，并平衡整个系统的各个模块(依照业务需求)。**</u>

# 垃圾回收算法

## 标记-清除算法

标记-清除是为了解决引用计数法的问题而提出。它使用了根集的概念，它分为“标记”和“清除”两个阶段：首先可达性标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程就是可达性分析法中判定垃圾对象的标记过程。

**优点：**不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。
		**缺点：**标记和清除过程的效率都不高，需要维护一个空闲列表来记录所有的空闲区域以及大小，加大了开销；标记清除后会产生大量不连续的内存碎片。

## 标记-整理算法

首先可达性标记出所需回收的对象，标记的过程与“标记-清除”算法中的一样，然后让让所有存活的对象都向一端移动，直接清理掉端边界以外的内存。在基于“标记-整理”算法的收集器的实现中，一般增加句柄和句柄表。

**优点**：解决了内存碎片的问题

**缺点**：GC 暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。

## 复制算法

复制算法是为了克服句柄的开销和解决堆碎片的垃圾回收。它将内存按容量分为大小相等的两块A和B，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。

1. 向A中分配内存，某一时刻A要用完了，复制存活对象到B中，清空A
2. 转而从B中分配内存，
3. 某一时刻B要用完了，复制存活对象到A中，清空B

复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如“标记-整理”算法。

**优点：**标记阶段和复制阶段可以同时进行；每次只对一块内存进行回收，运行高效；j解决了内存碎片问题
		**缺点：**需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。

## 分代收集算法

将堆进行如下分代分区

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-06_22-04-18.png)

几乎所有新生成的对象首先都是放在年轻代的，当Eden空间申请失败时会发起一次 GC（Minor GC / **Scavenge GC**）。存活对象的年龄会+1。

1. 当Eden区要满时，复制 Eden 区和 S1 区存活对象到 S0 区，然后清空 Eden 和 S1 区 
2. 当Eden区要满时，复制 Eden 区和 S0 区存活对象到 S1 区，然后清空 Eden 和 S0 区 
3. 如此往复，S0和S1交替使用

默认情况下，如果对象年龄达到 15 岁，就会移入到老年代中。若老年代也满了就会触发一次 GC（Major GC / **Full GC**），也就是新生代、老年代都进行回收。

### 新生代：

**为什么8:1:1的**

经研究，Eden区经过一轮GC会释放90-95%的对象，故起初设定为9:1

1. 9:1下的GC
   1. 标记-清除算法 ，有碎⽚化问题，影响内存使用效率
   2. 标记-整理算法，(整理算法,内存合并算法) ，相当耗费cpu 
2. 为了保证1.，并在不整理的情况下保证内存的完整性 ，使用分代 + 复制算法。新开辟一块区域【to区】专用于GC后存活对象的复制，然后清空Eden和from区，再to区中的对象移入from区。

### 老年代：

1. GC超过15次的对象【具体阈值在0-15之间，可以通过`-XX：MaxTenuringThreshold`参数进行控制】
2. 大对象：超过Eden内存的1/2的对象
3. 空间担保机制：当Eden区经过GC后发现from区装不下，就会直接移入Old区
4. 动态年龄判断机制：新生代内经过多次GC后仍未释放的对象，当其GC次数超过给定阈值时会认定往后也不会被释放，将直接移入Old区。

# 垃圾回收器

垃圾回收（GC）线程与应用线程保持相对独立，当系统需要执行垃圾回收任务时，先停止工作线程，然后命令 GC 线程工作。以串行模式工作的收集器，称为Serial Collector，即串行收集器；以并行模式工作的收集器，称为Paraller Collector，即并行收集器。

## 经典组合

|      新生代       |    老年代    |
| :---------------: | :----------: |
|      Serial       |  Serial Old  |
|      ParNew       |     CMS      |
| Parallel Scavenge | Parallel Old |

### 新生代

#### Serial 收集器

串行收集器采用单线程方式进行收集，不允许应用线程打扰，此时，应用程序进入暂停状态，即 Stop-the-world。Stop-the-world 暂停时间的长短，是衡量一款收集器性能高低的重要指标。Serial 是针对新生代的垃圾回收器，采用“复制”算法。

#### ParNew 收集器

并行收集器充分利用了多处理器的优势，采用多个 GC 线程并行收集。一般来说，与串行收集器相比，在多处理器环境下工作的并行收集器能够极大地缩短 Stop-the-world 时间。ParNew 是针对新生代的垃圾回收器，采用“复制”算法，是 Serial 的多线程版本

#### Parallel Scavenge 收集器

Parallel Scavenge 采用“复制”算法和 ParNew 类似，但更注重吞吐率。吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。如虚拟机总运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。
		**通过 VM 选项可以控制吞吐量的大致范围：**

+ -XX：MaxGCPauseMills：期望收集时间上限，用来控制收集对应用程序停顿的影响。
+ -XX：GCTimeRatio：期望的 GC 时间占总时间的比例，用来控制吞吐量。
+ -XX：UseAdaptiveSizePolicy：自动分代大小调节策略。

### 老年代

#### Serial Old 收集器

Serial Old 是 Serial 收集器的老年代版本，单线程收集器，采用“**标记-整理**”算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。

#### Parallel Old 收集器

Parallel Old 是 Parallel Scanvenge 收集器的老年代版本，多线程收集器，采用“**标记-整理**”算法。

#### CMS收集器

CMS（`Concurrent Mark Swee`）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS 收集器仅作用于老年代的收集，采用“****”算法，它的运作过程分为 4 个步骤：

1. 初始标记（CMS initial mark）             **Stop-the-world**，仅标记GCRoots直接关联的对象
2. 并发标记（CMS concurrent mark）   标记所有的Old对象，递归扫描，并发时有引用变动的对象会产生漏标问题
3. 重新标记（CMS remark）                    **Stop-the-world**，对2的并发误差进行修正
4. 并发清除（CMS concurrent sweep） “标记-清除”算法

## G1收集器

为了实现STW的时间可预测（在任意1秒的时间内，停顿不得超过xxxms）。G1将堆内存“化整为零”得多个大小相等独立区域（Region），每一个Region均可担负新生代的Eden空间、Survivor空间，或者老年代空间。
<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_16-51-21.png" style="zoom:67%;" />

+ 每个Region的大小可以通过参数`-XX:G1HeapRegionSize`设定，取值范围为1MB~32MB，且应为2的N次幂。

+ 超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中
+ G1的进行回收大多数情况下都把Humongous Region作为老年代的一部分来进行看待。
+ G1在逻辑上还是划分Eden、Survivor、OLd，但是物理上他们不是连续的。

它的运作过程分为 4 个步骤：

1. 初始标记             **Stop-the-world**，仅标记GCRoots直接关联的对象
2. 并发标记             标记所有的Old对象，递归扫描，并发时有引用变动的对象会产生漏标问题
3. 最终标记            **Stop-the-world**，对2的并发误差进行修正
4. 筛选回收            根据用户所期望的停顿时间来制定回收计划，把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。

