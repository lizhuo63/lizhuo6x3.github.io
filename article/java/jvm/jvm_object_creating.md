# 对象的创建过程

## Step1类加载检查

虚拟机遇到new指令时，先去检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。

## Step2分配内存

对象所需的内存⼤⼩在类加载完成后便可确定。为对象分配空间的⽅式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配⽅式由 Java 堆是否规整决定，⽽ Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。

内存分配的两种⽅式：

+ **指针碰撞：**
    + 原理：维护一个分界指针，通过控制分界指针向空闲内存方向移动，实现将使用过的内存整合划界，已达到没有内存碎片的目的
    + 适用于堆内存规整的情况
    + GC收集器：Serial、ParNew
+ **空闲列表：**
    + 原理：维护一个列表，在该表中记录可用的内存块，在分配时会找出合适大小的内存块，然后更新列表
    + 适用于堆内存不规整的情况
    + GC收集器：CMS

实现线程安全的方式：

+ **CAS+失败重试：** 冲突失败就重试，直到成功为⽌。虚拟机采⽤CAS配上失败重试的⽅式保证更新操作的原⼦性。
+ TLAB： 为每⼀个线程预先在 Eden 区分配⼀块⼉内存，JVM 在给线程中的对象分配内存
    时，⾸先在 TLAB 分配，当对象⼤于 TLAB 中的剩余内存或 TLAB 的内存已⽤尽时，再采⽤
    上述的 CAS 进⾏内存分配

## Step3赋初值

虚拟机需要为分配到的内存空间都赋初值（不包括对象头），它保证了对象的实例字段在 Java 代码中可以不赋值就直接使⽤，程序能访问到的是对应类型的零值。

## Step4设置对象头元信息

虚拟机要对对象设置必要的元信息，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。这些信息存放在对象头中。 

## Step5执⾏init⽅法

至此⼀个新的对象已经产⽣了，但从 Java 程序的视⻆来看， <init> ⽅法还没有执⾏，所有的字段都还为初值。所以执⾏ <init> ⽅法把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全产⽣出来。

