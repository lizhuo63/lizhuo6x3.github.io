# 加载机制

## 基本流程

hello.java→javac（将程序编译为字节码文件，存放在硬盘上，需要加载到内存中）→【字节码文件（字节流）JVM无法识别，需要类加载机制】→加载到内存→验证→准备→解析

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_10-00-34.png" style="zoom:67%;" />

## NO.1加载

### 【非数组类型】

0. javac编译.java文件，生成字节码文件并存于**硬盘内**【编译阶段】

1. 找到字节码文件（字节流）并载入**内存**（没有指明必须从哪获取）

    ​		1、从压缩包中读取，如jar、war 

    ​		2、从⽹络中获取，如Web Applet 

    ​		3、动态⽣成，如动态代理、CGLIB 

    ​		4、由其他⽂件⽣成，如JSP 

    ​		5、从数据库读取 

    ​		6、从加密⽂件中读取 

2. 对字节码文件进行解析，解析成运行时数据并存于**方法区**，此时字节码文件已释放

3. 在**堆区**生成该类的Class对象【**此时为空对象，什么都没有，须在准备阶段赋初值加载成员变量**】，即instanceMirrorKlass实例【生成镜类的原因的保护元信息，防止用户使用C++手段威胁JVM】，`类变量存储在堆区`

### 【数组类型】

不通过类加载器创建，而是由Java虚拟机直接在内存中动态构造出来的。如果数组装载的是引用类型元素，则会递归加载该元素的类型；若装载的元素是基本应用类型，则虚拟机会把该数组与引导类加载器关联起来。

 数组类的可访问性与它的元素类型的可访问性一致，对于基本用类型元素来说，数组类的可访问性默认为public。 

## NO.2验证

检查文件是否符合JVM规范

- **文件格式验证**

    - 是否以魔数0xCAFEBABE开头。 
    - 主、次版本号是否在当前Java虚拟机接受范围之内。
    - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 
    - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 
    - CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 
    - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
    - ……

- **元数据验证**

    - 是否有父类
    - 父类是否继承了不允许被继承的类（被final修饰的类）。
    - 非抽象类是否实现了父类或接口中要求实现的所有方法。
    - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。
    - ……

- **字节码验证**

    利用“StackMapTable”属性，将任务前置并分摊给了编译器，此阶段只需要检查StackMapTable属性中的记录是否合法即可。

    - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
    - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，
    - 保证方法体中的类型转换总是有效的
    - ……

- **符号引用验证**

    对类自身以外的各类信息进行匹配性校验，检查该类是否缺少或者被禁止访问它依赖的外部类、方法、字段等资源。确保解析阶段能正常执行。

    - 符号引用中通过字符串描述的全限定名是否能找到对应的类。 

    - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 

    - 符号引用中的类、字段、方法是否可被当前类访问。

    - ……

## NO.3准备

- 为静态变量【归属于class，但在jdk8以后存储在堆区】分配内存、赋初值。其目的是**将该变量写入class对象中去**。【初始化阶段执行静态代码段的规则 ——> 静态变量有赋值才会在静态代码段中生成代码。如果此时不声明静态变量，不为他赋初值，那么在下一步初始化赋值的时候，那些在源代码中没有赋（初）值的static int a；在静态代码段中就不会生成初始化代码，a就**会丢失**】
- 如果被**final修饰**，在编译的时候会给属性添加ConstantValue属性，准备阶段直接从常量池表中取值完成赋值，即没有赋初值这一步
- <u>实例变量是在创建对象的时候完成赋值的，没有赋初值一说</u>

## NO.4解析

解析：符号引用【常量池索引】→直接引用【能直接指向目标内容的引用（内存地址）】

+ 如果加载类中包含有其他引用类型，则在解析之前，此类型均没有指向具体的Xxx.class，仅代表一个符号【不完全类型】，通过解析后，该类型便可与实际指向的A.class文件实现映射对应。

+ 仅第一次运行时需要解析[运⾏时常量池的缓存机制【类似hashtable的数据结构】]，通过符号引用去常量池找到类信息将其存储到常量池中，其后改写，直接使用内存地址

### 解析时机

在类初始化之前检查并实现解析，由初始化触发解析

### 解析目标

对所有的符号引用都进行解析

1. 继承的类，实现的接口 ——> 存放于方法区
2. 字段 ——> 存放于堆
3. 类方法，接口方法 ——> 存放于方法区

## NO.5初始化

执行类构造器的<clinit>()方法，完成静态变量的赋值。**静态字段、静态代码段**会在字节码层面会生成clinit方法，方法中语句的先后顺序与代码的编写顺序相关。

- 如果没有静态属性，静态代码块，生成的字节码文件就没有clinit方法块
- final修饰的，不会在clinit方法块中体现，已在准备阶段赋值完毕
- 一个字节码文件只有一个clinit方法块
- clinit方法块中的代码顺序与java代码一致，会影响程序的最终结果

初始化阶段无线程安全问题，但是仍会发生初始化的死锁问题【是为JVM级别的锁，java检测工具无法识别】

### 初始化时机：

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/2022-06-14_18-23.png)

1. **new**，**访问**或**设置**某个类的<u>**静态字段**（final修饰【要求左右值均为不变量】以及位于常量池的除外</u>）、**调用某个类的静态方法**直接操作一个类 时，对该类初始化。``当父接口的变量被使用时才会被初始化。接口实现类的初始化不会触发接口的初始化。 ``
2. 反射(调用)某个类时，若该类未初始化，对该类初始化。
3. 当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化。
4. 启动类（main函数所在类）必定会初始化。
5. 若初始化类**实现了某接口的默认方法**，会先触发该接口初始化。
6. 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化

总结一句话：**用到就加载，不用不加载**

+ 常量在编译时会将其常量值存入使用该常量的类的常量池中，该过程不需要调用常量所在的类，因此不会触发该常量类的初始化。
+  在子类引用父类的静态字段时，不会触发子类的初始化，只会触发父类的初始化。
+ 定义对象数组，不会触发该类的初始化。
+ 在使用类名获取Class对象时不会触发类的初始化。
+ 在使用Class.forName加载指定的类时，可以通过initialize参数设置是否需要对类进行初始化。
+ 在使用ClassLoader默认的loadClass方法加载类时不会触发该类的初始化。

### 初始化顺序

1. ==静态的【(变量，块)从上到下】==
    1. 父类的
    2. 本类的
2. 父类非静态的【(变量，块)从上到下】
3. 父类构造函数
4. ==本类非静态的【(变量，块)从上到下】==
5. ==本类构造函数==

## 过程总结

1. .java源代码→javac编译为字节码文件.class，并存放在硬盘上
2. 将.class文件加载到jvm的方法区内
    1. 找到字节码文件并载入**内存**
    2. 对字节码文件进行解析，将生成的运行时数据【即instanceKlass实例(class结构体)】存于**方法区**，并释放.class文件
    3. 在**堆区**生成该类的Class对象【**此时为空对象**】
3. 验证，检查该.class是否符合JVM规范
4. 准备
    1. 为静态变量【归属于class】分配内存、赋初值(若被final修饰就直接完成赋值)，并将其存于堆区。
5. 解析，有常量池中的符号引用定位到直接引用。
    + 继承的类，实现的接口 ——> 进行加载并存放于方法区
    + 字段 ——> 存放于堆
    + 类方法，接口方法 ——> 存放于方法区
6. 初始化
    1. 执行静态代码块clinit，完成静态变量的赋值。



# 类加载器

根据一个类的全限定名来读取此类的二进制字节流(.class文件)到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例。

在Java中，一个类用其全限定类名作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。

## 分类

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_10-25-07.png" style="zoom:67%;" />

#### 启动（Bootstrap）类加载器

加载位于/jre/lib目录中的或者被参数-Xbootclasspath所指定的目录下的核心Java类库【rt.jar等等】。此类加载器是Java虚拟机的一部分，使用native代码(C++)编写。

#### 扩展（Extension）类加载器

加载位于/jre/lib/ext目录中的或者java.ext.dirs系统变量所指定的目录下的拓展类库。此加载器由sun.misc.Launcher$ExtClassLoader实现。由Java语言实现，父类加载器为null。

#### 应用（Application）类加载器

加载用户路径(ClassPath)上所指定的类库。此加载器由sun.misc.Launcher$AppClassLoader实现。由Java语言实现，父类加载器为ExtClassLoader。

## 双亲委派

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-07_10-27-59.png" style="zoom: 80%;" />

### 过程体现

如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是委托给自己的父类去加载，父类又委托给自己的父类。因此所有的类加载都会委托给顶层的父类（Bootstrap Classloader）进行加载，然后父类自己无法完成这个加载请求，子加载器才会尝试自己去加载。

**优势**

1. **避免类的重复加载**。java的类加载器具备了一种带有优先级的层次关系，通过这种层级关系，当父类加载器已经加载了该类时，就没有必要子ClassLoader再加载一次。
2. **防止核心API库被随意篡改**。当加载一个与Java核心类库中同类名的类时，由于启动类加载器已经加载了javaAPI中的同名类，所有目标类将无法加载。

### 打破双亲委派

打破双亲委派的意思其实就是**不委派、向下委派**。出现了父类或接口【由jdk底层提供】须由启动类加载器加载，而其子类或接口【第三方提供或自定义】须由应用类加载器加载，故而出现了上层必须向下层委派的情况。

例如：在某些情况下⽗类加载器需要委托⼦类加载器去加载class⽂件。受到加载范围的限制，⽗类加载器⽆法加载到需要的⽂件，以Driver接⼝为例，由于Driver接⼝定义在jdk当中的，⽽其实现由各个数据库的服务商来提供，⽐如mysql的就写了 MySQL Connector ，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接⼝的实现类，然后进⾏管理，但是DriverManager由启动类加载器加载，只能加载JAVA_HOME的lib下⽂件，⽽其实现是由服务商提供的，由系统类加载器加载，这个时候就需要 启动类加载器来委托⼦类来加载Driver实现，从⽽破坏了双亲委派。

 Java中存在很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，是⼀种**服务发现机制**。它通过在ClassPath路径下的META-INF/services⽂件夹查找⽂件，⾃动加载⽂件⾥所定义的类。这⼀机制为很多框架扩展提供了可能，⽐如在Dubbo、JDBC中都使⽤到了SPI机制 。