# 内置锁

使用方便，但功能单一，此外存在锁的膨胀情况。

## 无锁

Java对象刚创建时还没有任何线程来竞争，说明该对象处于无锁状态（无线程竞争它）

## 偏向锁

偏向锁是指一段同步代码一直被同一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。当有一个线程来竞争锁时，先用偏向锁，表示内置锁偏爱这个线程，这个线程要执行该锁关联的同步代码时，不需要再做任何检查和切换。偏向锁在竞争不激烈的情况下效率非常高。

在实际场景中，如果一个临界区没有多个线程竞争，而总是由同一个线程多次重入获取锁，即不存在线程竞争，那么锁就进入偏向状态。日后该线程获取锁时通过判断线程ID和标志位，就可以直接进入同步块，连CAS操作都不需要。**偏向锁的主要作用是消除无竞争情况下的同步原语，但在线程竞争的场景下它就是多余的。**



## 轻量级锁(自旋锁)

当锁处于偏向锁，又被另一个线程企图抢占时，偏向锁就会升级为轻量级锁。企图抢占的线程会通过自旋 (忙等待) 的形式尝试获取锁【会消耗CPU】，不会阻塞抢锁线程【会引起核态的切换】，以便提高性能。所以在使用的时候要设置最长等待时间，JDK 1.6之后引入了适应性自旋，可动态判断自旋次数。

轻量级锁的主要目的是在多线程竞争不激烈的情况下，尽可不动用操作系统层面的互斥锁，因为其性能比较差。通过CAS自旋机制竞争锁减少重量级锁核态切换产生的性能损耗。

### 普通自旋锁

当有线程来竞争锁时，抢锁线程会在原地循环等待，该过程小号CPU，相当于执行了空等待。默认自旋10次。



### 自适应自旋锁

指自旋次数是动态确定的。

1. 若抢锁线程成功获得过**该锁**，JVM就会认为这次自旋很有可能再次成功，因此允许自旋加时。
2. 若对于某个锁，抢锁线程很少成功获得过，那么JVM将会减少自旋时间甚至省略自旋过程，以避免浪费CPU资源。



## 重量级锁

如果线程在长时间内还未释放锁资源，就会造成多个线程自旋等待空耗CPU资源。抢锁线程会放弃自旋，该锁会膨胀为重量级锁。重量级锁会造成CPU在用户态和核心态之间频繁切换，所以代价高、效率低。

在JVM中，每个对象都关联一个监视器 [包含Object实例和Class实例]。监视器是一个同步工具，相当于一个临界区许可证。重量级锁通过监视器保障了任何时间内只允许一个线程进入临界区代码。



## 锁的执行流程（膨胀历程）

1. 线程抢锁时，JVM首先检测锁对象是否是为可偏向状态。即锁对象Mark Word中的biased_lock（偏向锁标识）是否为1，lock（锁标志位）是否为01。
2. 在确认锁对象为可偏向状态之后，JVM检查该偏向锁是否偏向当前的抢锁线程。即锁对象的Mark Word中的线程ID是否为抢锁线程ID。如果是，抢锁线程就获得锁并进入临界区。
3. 若锁对象Mark Word中的线程ID并未指向抢锁线程，就通过CAS自旋竞争锁。若竞争成功，就将偏向线程设置为当前的抢锁线程，然后进入临界区。此时锁对象处于偏向锁状态。
4. 若CAS自旋竞争失败，就说明发生了竞争，将撤销偏向锁升级为轻量级锁。
5. JVM使用CAS将锁对象的Mark Word替换为抢锁线程的锁记录指针，如果成功，抢锁线程就获得锁。如果替换失败，就表示其他线程竞争锁，JVM尝试使用CAS自旋替换抢锁线程的锁记录指针，如果自旋成功（抢锁成功），那么锁对象依然处于轻量级锁状态。**即先尝试直接拿，失败了就老实来 "抢"。**
6. 如果JVM的CAS替换锁记录指针自旋失败，轻量级锁就膨胀为重量级锁，后面等待锁的线程也要进入阻塞状态。

+ synchronized

synchronized是同步阻塞，采用的是悲观并发策略，是JVM级别的。

# 显示锁

## 功效

**<u>锁的状态总共有 4种：无锁、偏向锁、轻量级锁和重量级锁。</u>**

在Java内置锁的基础上，提供了额外的强大功能。

+ 限时抢锁：在抢锁时设置超时时长，如果超时还未获得锁就放弃，不至于无限等下去。
+ 可中断抢锁：在抢锁时，外部线程给抢锁线程发一个中断信号，就能唤起等待锁的线程，并终止抢占过程。
+ 多个等待队列：为锁维持多个等待队列，以便提高锁的效率。

顶级接口 Lock，Lock是同步非阻塞，采用的是乐观并发策略。是API级别的，通过Lock可以知道有没有成功获取锁，可以分别定义读写锁提高多个线程读操作的效率。

**中断锁的获取：** synchronized关键字在线程没有获取到锁使会被阻塞，期间该线程是不响应中断信号（interrupt）的；而调用Lock.lockInterruptibly()方法获取锁时，如果线程被中断，线程将抛出中断异常。

**非阻塞获取锁：** synchronized关键字在获取锁失败时只有被阻塞；而调用Lock.tryLock()获取锁失败时，线程也不会被阻塞，而是直接返回false。

**可限时抢锁：** synchronized关键字在获取锁时，如果不能抢到锁，线程只能无限制阻塞。调用Lock.tryLock(long time,TimeUnit unit)可以设置限定抢占锁的超时时间。

**常用API：**

+ **lock( )：**获取锁，死锁风险很高
+ **tryLock(long time, TimeUnit unit)：**在指定时间内，若当前锁对象已被其他线程持有或超时，则放弃申请该锁
+ **isHeldByCurrentThread()：**判断锁是否被当前线程所持有
+ **lockInterruptibly( )：**如果当前线程未被中断则获得锁，若被 **interrupt( )** 中断就报异常并终止当前线程。
+ **newContition( )：**该方法返回 Condition 对象，该类的await()、signal( )可实现等待/通知模式，需要持有Lock锁对象。创建多个Condition 对象可实现指定线程的等待通知，更加灵活。
  + **await( )：**令线程等待，并释放锁
  + **singal( )：**当前 Condition 对象的等待队列中唤醒 一个线程，尝试申请锁，成功后继续执行

**技巧：**

+ 释放锁

  ```java
  finally {
  		if (lock.isHeldByCurrentThread()){
  				lock.unlock();
  		}
  }
  ```




## ReentrantLock (可重入锁)

可重入锁也叫作递归锁，指在同一线程中，在外层函数获取到该锁之后，内层的递归函数仍然可以继续获取该锁。ReentrantLock和synchronized都是可重入锁，但多出了限时抢占、可中断抢占等功能。可多次获取同一把锁，能够避免死锁。它是一个**独占锁**。

<u>ReentrantLock 配合使用 lockInterruptibly( )和 interrupt( ) 可有效避免死锁问题。</u>

```java
Lock lock = new SomeLock();
阻塞式抢占: {
     lock.lock();
     try {
          //获取本锁保护的资源
          System.out.println(Thread.currentThread().getName() + "开始执行任务");
     } finally {
            lock.unlock();
     }
}
非阻塞式抢占: {
     if(lock.tryLock(1, TimeUnit.SECONDS)){
       	try {
          //获取本锁保护的资源
          System.out.println(Thread.currentThread().getName() + "开始执行任务");
     		} finally {
            lock.unlock();
    	  }
     }else{
        //限时抢锁失败，执行后备操作
     }
}
```

**常用API：**

+ int getHoldCount() 返回当前线程调用 lock()方法的次数
+ int getQueueLength() 返回正等待获得锁的线程预估数
+ int getWaitQueueLength(Condition condition) 返回与 Condition 条件相关的等待的线程预估数
+ boolean hasQueuedThread(Thread thread) 查询参数指定的线程是否在等待获得锁
+ boolean hasQueuedThreads() 查询是否还有线程在等待获得该锁
+ boolean hasWaiters(Condition condition) 查询是否有线程正在等待指定的 Condition 条件
+ boolean isFair() 判断是否为公平锁
+ boolean isHeldByCurrentThread() 判断当前线程是否持有该锁
+ boolean isLocked() 查询当前锁是否被线程持有；



## 读写锁

### ReentrantReadWriteLock

java.util.concurrent.locks包中定义了ReadWriteLock接口，是读写锁的顶层接口。

​		ReentrantReadWriteLock是一种对synchronized和ReentrantLock这些排他锁的改进，读之前必须获取读锁，更新之前需获取写锁。它**<u>允许并发读串行写</u>**，写锁是排他锁，读锁是共享锁，不允许这两种锁被同时持有。用于保障多线程并发读取到最新的共享数据。**读读共享, 读写互斥,写写互斥。**

**注意：**readLock()与writeLock()方法返回的锁对象是同一个锁的两个不同的角色, 而不是分别获得两个不同的锁对象。即ReadWriteLock 接口实例可以充当两个角色。

```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock readLock = rwLock.readLock();
Lock writeLock = rwLock.writeLock();
//读数据
readLock.lock(); //申请读锁
try{
// 读取共享数据
}finally{
		readLock.unlock(); 
}
//写数据
writeLock.lock(); //申请写锁
try{
// 更新修改共享数据
}finally{
		writeLock.unlock(); 
}
```

### StampedLock

StampedLock（印戳锁）是对ReentrantReadWriteLock的一种改进，表现为：在没有写只有读的场景下，StampedLock支持不用加读锁而是直接进行读操作，只有在发生过写操作之后，再加读锁才能进行读操作。



## 悲观锁和乐观锁

### 悲观锁

包括有独占锁、synchronized、

在多线程竞争下，会频繁进行核态切换，挂起所有未持锁的抢锁线程，有较大的性能问题

### 乐观锁

#### CAS自旋锁

**自旋锁：** 当一个线程在抢占锁的时候，如果锁已经被其他线程获取，调用者就一直在那里自旋检查该锁是否已经被释放，一直到获取到锁才会退出循环。

线程抢锁期间状态不会改变，一直是运行状态（RUNNABLE），在操作系统层面线程处于用户态。性能好但存在CPU资源耗尽的风险。

#### CLH自旋锁

基于单向链表实现，首先通过CAS将抢锁线程加入到链尾，之后对其前驱进行普通自旋，等待前驱释放锁，能大大减少CAS操作的数量，以避免CPU的总线风暴。



## 公平锁与非公平锁

​	**公平锁：**优先将锁分配给排队时间最长的线程，即**先来后到原则**。在一个回合内，实现所有线程都获取一遍锁。`new ReentrantLock(true);`可获取一个公平锁。它需要维护一个有序队列，成本高性能低，默认是不采用的。

​	**非公平锁：** 在分配锁时不考虑线程排队中的等待情况，直接尝试获取锁，**随机抢占**。所以大多数锁都是非公平的。包括synchronized、



## 可中断锁与不可中断锁

### 可中断锁

指抢占过程可以被中断的锁，如ReentrantLock

### 不可中断锁

指抢占过程不可以被中断的锁，如synchronized

## 共享锁和独占锁

### 独占锁

也叫排他锁、互斥锁、独享锁，指在同一时刻只允许一个线程持有该锁，ReentrantLock为独占锁的实现。

### 共享锁

在同一时刻允许多个线程同时获取该锁，获得共享锁的线程只能读取临界区的数据，不能修改临界区的数据。ReentrantReadWriteLock中的读锁为共享锁的实现。



## 分段锁

分段锁并非一种实际的锁，而是一种思想，用于将数据分段并在每个分段上都单独加锁，把锁进一步细粒度化，以提高并发效率。ConcurrentHashMap在内部就是使用分段锁实现的。



# AQS

抽象队列同步器，JUC并发包提供的并发工具。AQS提供了排他锁和共享锁两种机制

## 核心成员  

### `private volatile int state;`

表示资源的同步状态，使用 volatile保证线程可见，为此提供了compareAndSetState()实现原子更新。state初始值为0，表示资源未被锁定。当A线程抢占锁时会调用tryAcquire()独占该锁【**该过程由CAS保障多线程抢占的一个线程安全**】并将state加1，表示该资源已被锁定，若A线程重入该锁，则state会持续累加。届时其他线程再tryAcquire()时就会失败，直到A线程释放锁并重置state=0为止。实现了锁资源的排他独占。

### FIFO双向同步队列

若线程通过AQS抢占锁失败了，就会被封装为一个Node节点【内置有各种等待状态和前驱后继两个节点】，并通过CAS原子操作插入到队列尾部。