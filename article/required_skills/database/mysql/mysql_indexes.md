# 索引是个啥

​		它是一个支持排序的数据结构，对目标列建立索引可极大的提高该列各行的检索定位效率。它的初衷是为大数据提供加速检索服务的，所以考虑到了索引很大的情况，即决定了索引是存储在硬盘上的。

# MySQL索引类型

+ **普通索引：**对索引列没有任何限制，仅提供加速检索的服务

+ **唯一索引：**要求任意两个索引列的行数据不能重复，允许空值（仅一个）

+ **主键索引：** 一个表只能有一个主键索引，而且有非空限制

+ **联合索引：**为多个列建立**一个**索引，专用于组合搜索，<u>**搜索时条件列必须包含索引列的第一个列，否则联合索引不生效。**</u>

+ **全文索引：**用于查找文本中的关键字，一种模糊查询的思想，但是使用 `like '%asd%'` 会失效

  + 创建

    ```sql
    CREATE TABLE `table` (
        `content` text CHARACTER NULL ,
        FULLTEXT (content)
    );
    ```

  + 使用

    失效时，需要修改最小匹配的字符数；其次对中文分词支持不理想。

    ```sql
    select * from table where match(content) against('关键字' in natural language mode);
    ```

+ 聚集索引：它不是一个具体的索引类型，而是对满足特定场景的索引的别称。当某个索引的逻辑顺序与数据行的物理顺序一致时，就称该索引为聚集索引。如字典一般是根据abc排序的，它通常有拼音、偏旁、笔画等索引，但拼音索引与abc排序一致，那么拼音索引就是聚集索引。说白了，哪个索引底下有数据，谁就是聚集索引。
  + 如果有主键，主键索引就会顶上；
  + 没有主键就找到一个非空唯一的索引
  + 找不到目标，就由InnoDB生成的隐藏聚集索引 row_id 顶上

# 索引原理&结构

​		首先需要存储引擎从硬盘中走 I/O 逐个地载入索引节点【<u>**MySQL一次I/O加载一个页(16k)，而一个索引节点的大小刚好也是16k(页)，即一次I/O只能加载一个索引节点**</u>】

​		<u>**所以增加单个节点的数据量（减小索引列的大小），增加子节点的数量可以有效地减少磁盘I/O的次数，优化执行效率。**</u>

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-30_12-02-41.png)	

​	**MySQL的索引：**

​		采用了B+Tree的数据结构，它的特点就在数据插入的过程中树的节点会出现合并和分裂，但是当索引的键值有序时，这种分裂和合并的次数就非常少，性能上更优，存储上也不会产生大量的磁盘碎片。但如果使用UUID这种无序的K值，就会引起B+Tree节点的频繁合并和分裂，不仅影响性能而且会产生大量的磁盘碎片。<u>**所以如无特殊需求，索引键值还是设置成自增比较好。**</u>

​		此外，该索引的<u>**支节点是不存储数据(磁盘地址)的**</u>，所有的数据都统一存储在叶子节点上，这就极大的增加了每一个支节点的数据量，进一步减少了磁盘I/O的次数。

​		另外，叶子节点还维护了一个链表

**综上：Mysql的B+Tree索引的优点：**

+ 扫库、扫表的能力更强了。有叶子节点的链表加持。
+ 磁盘I/O次数更少
+ 排序查找能力更强，链表加持。
+ 效率更稳定，任意数据的I/O次数都一致

![image-20220630130035866](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/image-20220630130035866.png)

## 二级索引的查询

​		可宽泛地将索引划分为聚集索引和二级索引，区别就是二级索引不存储数据，它的叶子节点存储的是聚集索引的编号，当我们依赖二级索引来检索时，会先得到聚集索引的编号，再拿这个编号区聚集索引拿硬盘地址返回结果数据，这个被称之为回表。

## B+Tree在InnoDB的实现

​		关键文件：user_innodb.ibd。索引即数据，数据即索引。

## B+Tree在MyISAM的实现

两个关键文件：

+ user_myisam.MYD：(data)数据文件，存储数据
+ user_myisam.MYI：(index)索引文件，存储索引

![image-20220630133147727](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/image-20220630133147727.png)

​		工作流程：通过 user_myisam.MYI文件 的 B+Tree 来检索目标的磁盘地址，然后通过磁盘地址映射到 user_myisam.MYD文件 中指定的数据。



# 索引实用原则

## 建立索引

+ 禁止为离散度低的列建立索引，【离散度=不同数值的个数/行数】。
+ 联合索引的最左匹配原则。如一个联合索引abc，等同于建立了a、ab、abc三个索引。
+ 覆盖索引可以避免二级索引走回表。
  + 设where条件用到了索引列abc，select 的字段为 ？，当 ？含于abc时即覆盖索引成立。此时？= a、b、c、ab、ac、abc。(无顺序要求)，注意abc是索引列而不是条件列。
+ 依据查询条件建立索引，where、join、order by。
+ 索引个数不能过多
+ 不为随机无序，频繁更新的字段建立索引。

## 使用

+ 禁止在索引列上使用函数，表达式，运算符
+ 禁止出现类型隐式转换
+ 模糊查询like %asd%，禁用左前缀
+ 尽量不用负向查询 <>,!=,NOT IN，但是在主键上起效果





1. 将数据加载到内存中去
2. 从内存中二分查找，定位数据返回

+ **单值查询：**类似 `select name where id=1`, 由索引key定位数据value

  + 哈希表：O(1)  将索引列存入桶数组（充当目录），数据挂在桶下

+ **范围查询：**`select name where id > 5 and id < 12`，为了高效，希望索引列是有序的。

  + **有序数组：**O(1)，不利于数据增删

  + 搜索二叉树：O(logN)，存在数据倾斜（树不平衡）的情况

  + **AVL树：**解决了二叉树的不平衡问题，结构调整频繁引发高IO，效率差

  + **红黑树：**降低了AVL树的结构调整的要求，性能较AVL树更优，但仍然不适用充当磁盘介质（IO代价高）

  + 跳表：

  + **B tree：**

    + 节点中同时存储索引数值和真实数据，命中后可直接返回结束
    + 加大了存储占用，由于页的大小有限，会加大树高，降低性能

    ​	![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-09_13-01-03.png)

    

  + **B+tree：**

    + 将索引数值和真实数据分离，导致了可能会出现重复命中的情况，但是效率上影响不大

    ![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-06-09_13-08-47.png)

​			

