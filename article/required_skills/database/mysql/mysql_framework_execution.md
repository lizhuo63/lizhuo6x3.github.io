# 架构

![](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-05-29_21-22-00.png)

# 查询顺序

<img src="https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-05-29_21-43-13.png" style="zoom:67%;" />

## NO.1连接器

第一步，连接数据库。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：`mysql -h$ip -P$port -u$user -p`。mysql的连接策略为同步的TCP长连接。当前会话的最大连接数为151，全局最大连接数为10w。

1. 在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。
2. 认证通过后，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑都将依赖于此时读到的权限。

3. 连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。
4. 如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。

## NO.2查询缓存

连接建立完成后，执行逻辑就会来到第二步：查询缓存。

会频繁失效：**【只要有对一个表的更新，这个表上所有的查询缓存都会被清空】**，可以将 query_cache_type 设置为 DEMAIND，这样默认将不使用查询缓存，Mysql8已将查询缓存废除。

1. MySQL拿到查询请求后，会先到查询缓存看看，如果命中就直接返回，否则进入后续执行阶段。
2. 可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。

## NO.3分析器

如果没有命中查询缓存，就要开始真正执行语句。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。

1. 分析器先会做“词法分析”。MySQL需要识别出里面的字符串分别是什么，代表什么。

2. 随后做“语法分析”。语法分析器会根据语法规则，判断输入的SQL语句是否满足MySQL语法。

   **语法解析之后会得到一个解析树。**后续SQL的执行依赖于解析树的数据结构。

   ![image-20220629234926215](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/image-20220629234926215.png)

## **-预处理器-**

​		主要用于检查生成的解析树是否有效，即能否成功执行。主要包括以下方面

+ 表和列明的存在性
+ 别名的歧义性
+ 访问的权限校验

​		预处理器处理成功之后会会刷新解析树。

## NO.4优化器

​		经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理，得到执行计划。`EXPLAIN + SQL语句` 可查看对应sql的执行计划。

1. 在表里面有多个索引的时候，决定使用哪个索引
2. 在一个语句有多表关联（join）的时候，决定各个表的连接顺序

​		比如有两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而**优化器的作用就是决定选择使用哪一个方案。**

## NO.5执行器

​		通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

1. 开始执行的时候，要先判断一下你对这个表有没有执行查询的权限，如果没有，就会报错。
2. 打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。执行器相对于一个门面，而引擎才是实际的处理器。

## NO.6存储引擎层

​		存储引擎层负责数据的存储和提取，原因是使用场景和数据存储的业务需求的多样性，不同的引擎是从不同的业务需求中开发出来的，能够满足不同的需求。不同的存储引擎共用一个**Server层**，也就是从连接器到执行器的部分。mysql提供了存储引擎实现的诸多接口，大佬可以自实现一个存储引擎。



# 更新顺序（InnoDB）

​		service层几乎没有区别，只是不会走缓存。进入存储引擎后首先查询内存，若没有命中则需要将数据从磁盘中引入内存。MySQL根据局部性原理，会读取磁盘目标位置附近的数据以提高IO性能，它的I/O读取的最小单位是页(默认16k，OS的页大小默认为4k，InnoDB通过 **DoubleWrite Buffer** 来备份自己的页，实现页数据的完整)，然后将页存储到内存区【buffer pool(默认大小 128M)】中，内存中的页称为脏页，将脏页数据持久化的过程称为刷脏。 

​		更新数据它更新的是缓存中的数据，为防止内存数据丢失，InnoDB会将更新后的数据记录到 **redo.log**中，会有后台进程对缓存更新进行监听并实时刷新**redo.log**（追加日志），然后由LSN机制对比磁盘和缓存数据，找到差异点并实现持久化，多用于崩溃恢复，原因是数据不完整【循环覆盖记录】。【每个redo log的大小固定为1GB，为从头到尾循环覆盖写的模式】

+ redo.log采用顺序I/O，十分高效，每个日志文件默认48M	
+ redo.log属于物理日志，对指定数量的日志文件进行循环覆盖记录

+ 正常退出时，mysql会将缓存池中的数据持久化下来，保证下次启动时缓冲池中的热点数据不会丢失。意外宕机时，可根据redo.log恢复数据。
+ 最后三步将redo log 和binlog的写入纳入一个事务中，可以保证两个日志的记录效果一致，利于数据恢复。

​		此外，还有一个**undo.log**，他记录的是更新操作前的数据，主要用于事务回滚。

![image-20220630100226275](https://lizhuo-file.oss-cn-hangzhou.aliyuncs.com/img/image-20220630100226275.png)

## **执行顺序：**

0. Server层调用数据引擎 ，修改 **buffer pool** 中的数据【`update xxx set name='asd' where id=2`】，如果读写未命中缓存则需要先从硬盘中加载
1. 记录undo.log，为事务回滚做准备
2. 记录redo.log，为数据的崩溃恢复做准备
   1. 先设置预提交状态，通知Server层记录 **binlog**【用于数据恢复和主从复制，可无限制续写，记录完整数据，是数据恢复的依据】
   2. **binlog** 记录完毕之后，才认为事务可提交，然后通知事务接口将 **redo.log** 的事务状态设为 提交。
3. 将数据记录到 buffer pool (内存)中，{由后台线程刷脏}
4. 事务提交

## 两种日志的区别：

1. redo log 是 InnoDB 引擎特有的； binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是 “ 在某个数据页上有哪些数据做了哪些修改 ” ； binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “ 给 ID=2 这一行的 c 字段加 1 ” 。
3. redo log 是循环覆盖写的，空间固定； binlog 是可追加写，到一定大小后会切换写入下一个文件。 

